# Dictionaries, Sets, and Serializing Objects
## Dictionaries
- Object that stores a collection of data
- Each element consists of a key and value
  - Refered to as mapping of key to value
  - Key must be an immutable object (can't be list, set, or dict)
- To retrieve a specific value, use the key associated with it
- Format for creating dictionary:
```python
dictionary = {key1:val1, key2:val2}
```
## Retrieving values
- Elements in dictionary are unsorted
- General format for retrieving value from dictionary:
```python
return dictionary[key1] #returns val1
```
- If key in the dictionary, associated value is returned, otherwise, KeyError exception is raised
```python
return dictionary[key3] #KeyError is raised
```
- Use ```in``` and ```not in``` to test whether value is in dictionary, and prevent KeyError from being raised
## Adding Elements to an Existing Dictionary
- Dictionaries are mutable objects 
- To add a new key-value pair:
```python
dictionary[key3] = value3
```
- If key exists in the dictionary, the value associated with it will be changed 
```python
dictionary[key3] = 0
```
## Deleting Elements From an Existing Dictionary
- To delete a key-value pair:
```python
del dictionary[key3]
```
- If key is not in the dictionary, KeyError exception is raised
## Getting the Number of Elements and Mixing Data Types
- len function: used to obtain number of elements in dictionary
- Keys must be immutable objects, but associated values can be any type of object
  - One dictionary can include keys of several different immutable types
- Values stored in a single dictionary can be of different types
```python
key1 = 'Hello'
key2 = 34
key3 = (1, 4, 'Bye')
val1 = [1, 2, 3]
val2 = '34'
val3 = {'Hi':'Bye'}
dictionary = {key1:val1, key2:val2, key3"val3} #Notice keys are immutable, but values can be whatever type they want
```
## Dictionary Methods
|method name|what it does|
|---|---|
|clear|Clears the contents of a dictionary|
|get|Gets a value associated with specified key from the dictionary|
|items|returns all the dictionaries keys and associated values |
|keys|returns all the dictionaries keys as a sequence|
|pop|returns value associated with specified key and removes that key-value pair from the dictionary|
|popitem|returns a randomly selected key-value pair and removes that key-value pair from the dictionary|
|values|returns all the dictionaries values as a sequence|
## Sets
- object that stores a collection of data in same way as mathematical set
- All items must be unique 
- Set is unordered 
- Elements can be of different data types 
## Creating a Set
- For empty set, call ```set()```
- For non-empty set, call ```set(argument)``` where ```argument``` is an object that contains iterable elements
  - argument can be a list, string, or tuple
  - If argument is a string, each character becomes a set element 
  - If argument contains duplicates, only one of the duplicates will appear in the set 
## Getting the Number of and Adding Elements
- len function: returns the number of elements in the set 
- Sets are mutable objects 
- add method: adds an element to a set 
- update method: adds a group of elements to a set 
  - Argument must be a sequence containing  iterable elements, and each of the elements is added to the set 
## Deleting Elements From a Set
- remove and discard methods: remove the specified item from the set 
- The item that should be removed is passed to both methods as an argument 
- Behave differently when the specified item is not found in the set 
  - remove method raises a KeyError exception 
  - discard method does not raise an exception 
- clear method: clears all the elements of the set 
## Finding the Union of Sets
- A set that contains all the elements of both sets 
- To find the union of two sets: 
  - Use the union method  
    ```set1.union(set2)```
  - Use the | operator  
    ```Format: set1 | set2```
  - Both techniques return a new set which contains the union of both sets 
## Finding the Intersection of Sets
- A set that contains only the elements found in both sets 
- To find the intersection of two sets: 
  - Use the intersection method  
    ```set1.intersection(set2)```
  - Use the & operator  
    ```Format: set1 & set2```
  - Both techniques return a new set which contains the intersection of both sets 
## Finding the Difference of Sets
- A set that contains the elements that appear in the first set but do not appear in the second set 
- To find the difference of two sets: 
  - Use the difference method  
    ```set1.difference(set2)```
  - Use the - operator  
    ```Format: set1 - set2```
  - Both techniques return a new set which contains the difference of both sets 
## Finding the Symmetric Difference of Sets
- A set that contains the elements that are not shared by the two sets 
- To find the symmetric difference of two sets: 
  - Use the symmetric_difference method  
    ```set1.symmetric_difference(set2)```
  - Use the ^ operator  
    ```Format: set1 ^ set2```
  - Both techniques return a new set which contains the symmetric difference of both sets 
## Finding Subsets and Supersets
- Set A is subset of set B if all the elements in set A are included in set B 
- To determine whether set A is subset of set B 
  - Use the issubset method
  ```Format: setA.issubset(setB)```
  - Use the <= operator
  ```Format: setA <= setB```
- Set A is superset of set B if it contains all the elements of set B 
- To determine whether set A is superset of set B 
  - Use the issuperset method
  ```Format: setA.issuperset(setB)```
  - Use the >= operator
  ```Format: setA >= setB```
## Serializing Objects
- Serialize an object: convert the object to a stream of bytes that can easily be stored in a file  
- Pickling: serializing an object 
- To pickle an object: 
  - Import the pickle module 
  - Open a file for binary writing 
  - Call the pickle.dump function 
  ```Format: pickle.dump(object, file)``` 
  - Close the file 
- You can pickle multiple objects to one file prior to closing the file
- Unpickling: retrieving pickled object 
  - To unpickle an object: 
  - Import the pickle module 
  - Open a file for binary writing 
  - Call the pickle.load function 
  ```Format: pickle.load(file)``` 
  - Close the file 
- You can unpickle many objects from a file
# Classes and Object-Oriented Programming
## Procedural Programming
- Writing programs made of functions that perform specific tasks 
- Procedures typically operate on data items that are separate from the procedures 
- Data items commonly passed from one procedure to another 
- Focus: to create procedures that operate on the program’s data 
## Object-Oriented Programming
- Focused on creating objects
- Object: entity that contains data and procedures 
  - Data is known as data attributes and procedures are known as methods 
  - Methods perform operations on the data attributes
- Encapsulation: combining data and code into a single object 
- Data hiding: object’s data attributes are hidden from code outside the object 
  - Access restricted to only the object’s methods 
  - Protects from accidental corruption 
  - Outside code does not need to know internal structure of the object 
- Object reusability: the same object can be used in different programs  
  - Example: 3D image object can be used for architecture and game programming 
## An Everyday Example of an Object
- Data attributes: define the state of an object 
  - Example: clock object would have second, minute, and hour data attributes 
- Public methods: allow external code to manipulate the object 
  - Example: set_time, set_alarm_time 
- Private methods: used for object’s inner workings 
## Classes
- Class: code that specifies the data attributes and methods of a particular type of object 
  - Similar to a blueprint of a house or a cookie cutter 
- Instance: an object created from a class 
  - Similar to a specific house built according to the blueprint or a specific cookie 
  - There can be many instances of one class 
## Class Definitions
- Set of statements that define a class’s methods and data attributes 
```python
class Class_name:
```
- Method definition like any other python function definition
- self parameter: required in every method in the class – references the specific object that the method is working on
- Initializer method: automatically executed when an instance of the class is created
  - Initializes object’s data attributes and assigns self parameter to the object that was just created
  ```python
  def __init__ (self):
  ```
- To create a new instance of a class call the initializer method
```python3
My_instance = Class_Name()
```
- To call any of the class methods using the created instance, use dot notation
```python3
My_instance.method()
```
## Hiding Attributes and Storing Classes in Modules
- An object's data attributes should be private
  - To do this put two underscores (\__current_minute)
- Classes can be stored in modules
  - Filename for module must end in .py
  - Module can be imported to programs that use the class
## Accessor and Mutator Methods
- Typically, all of a class’s data attributes are private and provide methods to access and change them
- Accessor methods: return a value from a class’s attribute without changing it
  - Safe way for code outside the class to retrieve the value of attributes
- Mutator methods: store or change the value of a data attribute
## Passing Objects as Arguments
- Methods and functions often need to accept objects as arguments
- When you pass an object as an argument, you are actually passing a reference to the object
  - The receiving method or function has access to the actual object
# Inheritance
## Introduction to Inheritance
- In the real world, many objects are a specialized version of more general objects
  - Example: grasshoppers and bees are specialized types of insect, 
  - In addition to the general insect characteristics, they have unique characteristics:
    - Grasshoppers can jump
    - Bees can sting, make honey, and build hives
## Inheritance and the “Is a” Relationship
- “Is a” Relationship: exists when one object is a specialized version of another object
- Specialized object has all the characteristics of the general object plus unique characteristics
- Example: Rectangle **is a** shape
- Inheritance: used to create an “is a” relationship between classes 
- Superclass (base class): a general class 
- Subclass (derived class): a specialized class
  - An extended version of the superclass
  - Inherits attributes and methods of the superclass
  - New attributes and methods can be added
- For example, need to create classes for cars, pickup trucks, and SUVs
- All are automobiles
- Have a make, year model, mileage, and price 
  - This can be the attributes for the base class
- In addition:
  - Car has a number of doors 
  - Pickup truck has a drive type
  - SUV has a passenger capacity
- To indicate inheritance, the superclass name is placed in parentheses after subclass name
```python3
class Car(Automobile)
```
- The initializer method of a subclass calls the initializer method of the superclass and then initializes the unique data attributes
## Inheritance in UML Diagrams
- In UML diagram, show inheritance by drawing a line with an open arrowhead from subclass to superclass
## Polymorphism
- An object’s ability to take different forms
- Essential ingredients of polymorphic behavior:
  - Ability to define a method in a superclass and override it in a subclass
    - Subclass defines method with the same name
  - Ability to call the correct version of overridden method depending on the type of object that called for it
## isinstance function
- Polymorphism provides great flexibility when designing programs
- AttributeError exception: raised when a method is receives an object which is not an instance of the right class
- isinstance function: determines whether object is an instance of a class
```python3
isinstance(object, class)
```
# Recursion
## Introduction to Recursion
- Recursive function: a function that calls itself
- Recursive function must have a way to control the number of times it repeats
  - Usually involves an if-else statement which defines when the function should return a value and when it should call itself
- Depth of recursion: the number of times a function calls itself
## Problem Solving with Recursion
- Recursion is a powerful tool for solving repetitive problems
- Recursion is never required to solve a problem
  - Any problem that can be solved recursively can be solved with a loop
  - Recursive algorithms usually less efficient than iterative ones
    - Due to *overhead* of each function call
- Some repetitive problems are more easily solved with recursion
- General outline of recursive function:
  - If the problem can be solved now without recursion, solve and return
    - Known as the *base case*
  - Otherwise, reduce problem to smaller problem of the same structure and call the function again to solve the smaller problem
    - Known as the *recursive case*
## Using Recursion to Calculate the Factorial of a Number
- In mathematics, the *n!* notation represents the factorial of a number *n*
  - For *n* = 0, *n*! = 1
  - For *n* > 0, *n*! = 1 x 2 x 3 x … x *n*
- The above definition lends itself to recursive programming
  - *n* = 0 is the base case
  - *n* > 0 is the recursive case
    - factorial(*n*) = *n* x factorial(*n*-1)
- Since each call to the recursive function reduces the problem:
  - Eventually, it will get to the base case which does not require recursion, and the recursion will stop
- Usually the problem is reduced by making one or more parameters smaller at each function call
## Direct and Indirect Recursion
- Direct recursion: when a function directly calls itself
  - All the examples shown so far were of direct recursion
- Indirect recursion: when function A calls function B, which in turn calls function A
## The Fibonacci Series
- Fibonacci series: has two base cases
  - if n = 0 then Fib(n) = 0
  - if n = 1 then Fib(n) = 1
  - if n > 1 then Fib(n) = Fib(n-1) + Fib(n-2)
- Corresponding function code:
```python3
def fib(n):
   if n <= 1:
       return n
   else:
       return(fib(n-1) + fib(n-2))
```
## Finding the Greatest Common Divisor
- Calculation of the greatest common divisor (GCD) of two positive integers
  - If x can be evenly divided by y, then 
  - gcd(x,y) = y
  - Otherwise, gcd(x,y) = gcd(y, remainder of x/y)
- Corresponding function code:
```python3
def gcd(x , y):
    if y == 0:
        return x
    else:
        return gcd(y, x % y)
```
## Recursion versus Looping
- Reasons not to use recursion:
  - Less efficient: entails function calling overhead that is not necessary with a loop
  - Usually a solution using a loop is more evident than a recursive solution
- Some problems are more easily solved with recursion than with a loop
  - Example: Fibonacci, where the mathematical definition lends itself to recursion
# More about Strings
## String Slicing
- Slice: span of items taken from a sequence, known as substring
- Slicing format: string[start : end]
- Expression will return a string containing a copy of the characters from start up to, but not including, end
- If start not specified, 0 is used for start index
- If end not specified, len(string) is used for end index
- Slicing expressions can include a step value and negative indexes relative to end of string
## Methods
| Method         | Description                                                                                   |
|----------------|-----------------------------------------------------------------------------------------------| 
| capitalize()   | Converts the first character to upper case                                                    | 
| center()       | Returns a centered string                                                                     | 
| count()        | Returns the number of times a specified value occurs in a string                              | 
| endswith()     | Returns true if the string ends with the specified value                                      | 
| find()         | Searches the string for a specified value and returns the position of where it was found      | 
| index()        | Searches the string for a specified value and returns the position of where it was found      | 
| isalnum()      | Returns True if all characters in the string are alphanumeric                                 | 
| isalpha()      | Returns True if all characters in the string are in the alphabet                              | 
| isdecimal()    | Returns True if all characters in the string are decimals                                     | 
| isdigit()      | Returns True if all characters in the string are digits                                       | 
| isidentifier() | Returns True if the string is an identifier                                                   | 
| islower()      | Returns True if all characters in the string are lower case                                   | 
| isnumeric()    | Returns True if all characters in the string are numeric                                      | 
| isprintable()  | Returns True if all characters in the string are printable                                    | 
| isspace()      | Returns True if all characters in the string are whitespaces                                  | 
| istitle()      | Returns True if the string follows the rules of a title                                       | 
| isupper()      | Returns True if all characters in the string are upper case                                   | 
| join()         | Joins the elements of an iterable to the end of the string                                    | 
| lower()        | Converts a string into lower case                                                             | 
| lstrip()       | Returns a left trim version of the string                                                     | 
| replace()      | Returns a string where a specified value is replaced with a specified value                   | 
| rfind()        | Searches the string for a specified value and returns the last position of where it was found | 
| rindex()       | Searches the string for a specified value and returns the last position of where it was found | 
| rjust()        | Returns a right justified version of the string                                               | 
| rsplit()       | Splits the string at the specified separator, and returns a list                              | 
| rstrip()       | Returns a right trim version of the string                                                    | 
| split()        | Splits the string at the specified separator, and returns a list                              | 
| splitlines()   | Splits the string at line breaks and returns a list                                           | 
| startswith()   | Returns true if the string starts with the specified value                                    | 
| strip()        | Returns a trimmed version of the string                                                       | 
| swapcase()     | Swaps cases, lower case becomes upper case and vice versa                                     | 
| title()        | Converts the first character of each word to upper case                                       | 
| upper()        | Converts a string into upper case                                                             | 

# Files and Exceptions
## Updating Text Files
- Formatted data written to a text file cannot be modified without the risk of destroying other data
- If the name 'White' needs to be changed to 'Williams' in accounts.txt , the old name cannot simply be overwritten
- The original record for White is stored as
```300 White 0.00```
- If you overwrite the name 'White' with the name 'Williams' , the record becomes
```300 Williams00```
- The characters beyond the second “ i ” in 'Williams' overwrite other characters in the line
- The problem is that records and their fields can vary in size
- To make the preceding name change, we can:
  - copy the records before  300 White 0.00 into a temporary file,
  - write the updated and correctly formatted record for account 300 to this file,
  - copy the records after  300 White 0.00 to the temporary file,
  - delete the old file and
  - rename the temporary file to use the original file’s name.
- Requires processing *every* record in the file, even if you need to update only one record
  - More efficient when an application needs to update many records in one pass  of the file
**Updating accounts.txt**
- Update the  accounts.txt file to change account 300’s name from  'White' to  'Williams' as described above:
```python3
In [1]:
accounts = open('accounts.txt', 'r')
In [2]:
temp_file = open('temp_file.txt', 'w')
In [3]:
with accounts, temp_file:
 for record in accounts:
  account, name, balance = record.split()
  if account != '300':
    temp_file.write(record)
  else:
    new_record = ' '.join([account, 'Williams', balance])
    temp_file.write(new_record + '\n')
```
## Serialization with JSON
- **JSON (JavaScript Object Notation)** is a text-based, human-and-computer-readable, data-interchange format used to represent objects as collections of name–value pairs.
- Preferred data format for transmitting objects across  platforms.

**JSON Data Format**

- Similar to Python dictionaries
- Each JSON object contains a comma-separated list of **property names** and **values**, in curly braces.
```
{"account":100,"name":"Jones","balance":24.98}
```
- JSON arrays, like Python lists, are comma-separated values in square brackets. ```[ 100 ,  200 ,  300 ]```
- Values in JSON objects and arrays can be:
    - **strings** in **double quotes**
    - **numbers**
    - JSON Boolean values  **true** or  **false**
    - **null** (like  None in Python)
    - **arrays**
    - **other JSON objects**

**Python Standard Library Module json**
- **json module** enables you to convert objects to JSON (JavaScript Object Notation) text format
- Known as **serializing** the data
- Following dictionary, which contains one key–value pair consisting of the key  'accounts' with its asso ciated value being a list of dictionaries representing two accounts
```python3
In [3]:
accounts_dict = {'accounts': [
 {'account': 100, 'name': 'Jones', 'balance': 24.98},
 {'account': 200, 'name': 'Doe', 'balance': 345.67}]}
```
**Serializing an Object to JSON**
Write JSON to a file
json module’s dump function serializes the dictionary accounts_dict into the file
```python3
In [4]:
import json
In [6]:
with open('accounts.json', 'w') as accounts:
  json.dump(accounts_dict, accounts)
```

Resulting file contains the following text—reformatted slightly for readability:
```
{"accounts":
[{"account": 100, "name": "Jones", "balance": 24.98},
{"account": 200, "name": "Doe", "balance": 345.67}]}
```
JSON delimits strings with double-quote characters.

**Deserializing the JSON Text**
- json module’s  **load function** reads entire JSON contents of its file object argument and converts the JSON into a Python object
- Known as **deserializing** the data
```python3
In [7]:
with open('accounts.json', 'r') as accounts:
  accounts_json = json.load(accounts)
In [8]:
accounts_json
In [9]:
accounts_json['accounts']
Out[8]:
{'accounts': [{'account': 100, 'name': 'Jones', 'balance': 24.98},
 {'account': 200, 'name': 'Doe', 'balance': 345.67}]}
Out[9]:
[{'account': 100, 'name': 'Jones', 'balance': 24.98},
 {'account': 200, 'name': 'Doe', 'balance': 345.67}]
 In [10]:
accounts_json['accounts'][0]
In [11]:
accounts_json['accounts'][1]
Out[11]:
{'account': 200, 'name': 'Doe', 'balance': 345.67}
```
**Displaying the JSON Text**
- json module’s  **dumps function** ( dumps is short for “dump string”) returns a Python string representation of an object in JSON format
- Canbe used to display JSON in a nicely indented format
- sometimes called “pretty printing”
- When call includes the  indent keyword argument, the string contains newline characters and indentation for pretty printing
- Also can use  indent with the  dump function when writing to a file
```python3
In [12]:
with open('accounts.json', 'r') as accounts:
  print(json.dumps(json.load(accounts), indent=4))
```
## Division by Zero and Invalid Input
- Recall that attempting to divide by 0 results in a ZeroDivisionError :
- Interpreter raises an exception of type ZeroDivisionError
- Exception in IPython
  - terminates the snippet,
  - displays the exception’s traceback, then
  - shows the next In [] prompt so you can input the next snippet
- Exception in a script terminates it and IPython displays the traceback
## try statements
- Can *handle* exceptions so code can continue processing
- Following code uses exception handling to catch and handle (i.e., deal with) any  ZeroDivisionError s and  ValueError s that arise—in this case, allowing the user to re-enter the input
```python3
# dividebyzero.py
"""Simple exception handling example."""
while True:
 # attempt to convert and divide values
    try:
        number1 = int(input('Enter numerator: '))
        number2 = int(input('Enter denominator: '))
        result = number1 / number2
    except ValueError: # tried to convert non-numeric value to int
        print('You must enter two integers\n')
    except ZeroDivisionError: # denominator was 0
        print('Attempted to divide by zero\n')
    else: # executes only if no exceptions occur
        print(f'{number1:.3f} / {number2:.3f} = {result:.3f}')
        break # terminate the loop
```
You must enter two integers 
10.000 / 2.000 = 5.000

**try Clause**

- **try statements** enable exception handling
- **try clause** followed by a suite of statements that *might* raise exceptions

**except Clause**

- try clause’s suite may be followed by one or more  **except clauses**
- Known as *exception handlers*
- Each specifies the type of exception it handles

**else Clause**

![](DTL9.4-merged.041.png) After the last  except clause, an optional  **else clause** specifies code that should execute only if the code in the  try suite **did not raise exceptions**

**Flow of Control for a  ZeroDivisionError**

- The point in the program at which an exception occurs is often referred to as the **raise point**
- When an exception occurs in a  try suite, it terminates immediately
- If there are any  except handlers following the  try suite, program control transfers to the first one
- If there are no  except handlers, a process  called *stack unwinding* occurs (discusse d later)
- When an  except clause successfully handles the exception, program execution resumes with the finally clause (if there is one), then with the next statement after the  try statement.

**Flow of Control for a  ValueError**

**Flow of Control for a Successful Division**
When no exceptions occur in the  try suite, program execution resumes with the  else clause (if there is one); otherwise, program execution resumes with the next statement after the try statement
### Extra stuff
- If several except suites are identical, you can catch those exception types by specifying them as a tuple
- in a single except handler:
- except (type1, type2, …) as variable_name:
- as clause is optional
- Typically, programs do not need to reference the caught exception object directly
- Can use the variable in the as clause to reference the exception object in the except suite
- Before using any function or method, read its online API documentation
- Specifies what exceptions are thrown (if any) by the function or method
- Indicates reasons why such exceptions may occur
- Next, read the online API documentation for each exception type to see potential reasons why such an
- exception occurs
- For proper exception-handling granularity, each try statement should enclose a section of code small
- enough that, when an exception occurs, the specific context is known and the except handlers can
- process the exception properly
- If many statements in a try suite raise the same exception types, multiple try statements may be
- required to determine each exception’s context
# Array-OP with NumPy
## Intro
**NumPy (Numerical Python) Library**
- First appeared in 2006 and is the preferred Python array implementation.
- High-performance, richly functional n-dimensional array type called ndarray.
- Written in C and up to 100 times faster than lists.
- Critical in big-data processing, AI applications and much more.
- According to libraries.io, over 450 Python libraries depend on NumPy.
- Many popular data science libraries such as Pandas, SciPy (Scientific Python) and Keras (for deep learning)are built on or depend on NumPy.
**Array-Oriented Programming**
- Functional-style programming with internal iteration makes array-oriented manipulations concise andstraightforward, and reduces the possibility of error.
## Creating arrays from Existing Data
- Creating an array with the array function
- Argument is an array or other iterable
- Returns a new array containing the argument’s elements
```python3
In [1]:
import numpy as np
In [2]:
numbers = np.array([2, 3, 5, 7, 11])
In [3]:
type(numbers)
Out[3]:
numpy.ndarray
In [4]:
numbers
Out[4]:
array([ 2, 3, 5, 7, 11])
```
**Multi-Dimensional Arguments**
```python3
In [5]:
np.array([[1, 2, 3], [4, 5, 6]])
Out[5]:
array([[1, 2, 3],
 [4, 5, 6]])
```
## array attributes
- attributes enable you to discover information about its structure and contents
- The array function determines an array’s element type from its argument’s elements. 
- You can check the element type with an array’s dtype attribute:
- For performance reasons, NumPy is written in the C programming language and uses C’s data types. 
- By default, NumPy stores integers as the NumPy type int64 values— which correspond to 64-bit (8-byte) integers in C—and stores floating-point numbers as the NumPy type float64 values —which correspond to 64-bit (8-byte) floating-point values in C.
- The attribute ndim contains an array’s number of dimensions and the attribute shape contains a tuple specifying an array’s dimensions:
- You can view an array’s total number of elements with the attribute size and the number of bytes required to store each element with itemsize:
- You can iterate through a multidimensional array as if it were one-dimensional by using its flat attribute:
## Filling arrays with specific values
- Functions zeros, ones and full create arrays containing 0s, 1s or a specified value,respectively
```python3
In [1]: import numpy as np
In [2]: np.zeros(5)
Out[2]: array([ 0., 0., 0., 0., 0.])
```
```python3
In [4]: np.full((3, 5), 13)
Out[4]:
array([[13, 13, 13, 13, 13],
 [13, 13, 13, 13, 13],
 [13, 13, 13, 13, 13]])
```
## Creating arrays from ranges
- NumPy provides optimized functions for creating arrays from ranges. 
- We focus on simple evenly spaced integer and floating-point ranges, but NumPy also supports nonlinear ranges
```python3
In [1]: import numpy as np
In [2]: np.arange(5)
Out[2]: array([0, 1, 2, 3, 4])
In [3]: np.arange(5, 10)
Out[3]: array([5, 6, 7, 8, 9])
In [4]: np.arange(10, 1, -2)
Out[4]: array([10, 8, 6, 4, 2])
```
- You can produce evenly spaced floating-point ranges with NumPy’s linspace function. 
- The function’s first two arguments specify the starting and ending values in the range, and the ending value is included in the array. 
- The optional keyword argument num specifies the number of evenly spaced values to produce—this argument’s default value is 50:
```python3
In [5]: np.linspace(0.0, 1.0, num=5)
Out[5]: array([ 0. , 0.25, 0.5 , 0.75, 1. ])
```
- You also can create an array from a range of elements, then use array method reshape to transform the onedimensional array into a multidimensional array. 
- Let’s create an array containing the values from 1 through 20, then reshape it into four rows by five columns:
```python3
In [6]: np.arange(1, 21).reshape(4, 5)
Out[6]:
array([[ 1, 2, 3, 4, 5],
 [ 6, 7, 8, 9, 10],
 [11, 12, 13, 14, 15],
 [16, 17, 18, 19, 20]])
```
- You can reshape any array, provided that the new shape has the same number of elements as the original. 
- So a six-element one-dimensional array can become a 3-by-2 or 2-by-3 array, and vice versa, but attempting to reshape a 15- element array into a 4-by-4 array (16 elements) causes a ValueError.
- When displaying an array, if there are 1000 items or more, NumPy drops the middle rows, columns or both from the output. 
- The following snippets generate 100,000 elements. 
- The first case shows all four rows but only the first and last three of the 25,000 columns. 
- The notation ... represents the missing data. The second case shows the first and last three of the 100 rows, and the first and last three of the 1000 columns
## array operators
**Arithmetic Operations with arrays and Individual Numeric Values**
- First, let’s perform element-wise arithmetic with arrays and numeric values by using arithmetic operators and augmented assignments. 
- Element-wise operations are applied to every element, so snippet [4] multiplies every element by 2 and snippet [5] cubes every element. 
- Each returns a new array containing the result
```python3
In [1]: import numpy as np
In [2]: numbers = np.arange(1, 6)
In [3]: numbers
Out[3]: array([1, 2, 3, 4, 5])
In [4]: numbers * 2
Out[4]: array([ 2, 4, 6, 8, 10])
In [5]: numbers ** 3
Out[5]: array([ 1, 8, 27, 64, 125])
In [6]: numbers # numbers is unchanged by the arithmetic operators
Out[6]: array([1, 2, 3, 4, 5])
```
- Augmented assignments modify every element in the left operand.
**Broadcasting**
- Normally, the arithmetic operations require as operands two arrays of the same size and shape. 
- When one operand is a single value, called a scalar, NumPy performs the elementwise calculations as if the scalar were an array of the same shape as the other operand, - but with the scalar value in all its elements. 
- This is called broadcasting. Snippets [4], [5] and [7] each use this capability. 
- For example, snippet [4] is equivalent to:
```python3
numbers * [2, 2, 2, 2, 2]
```
- Broadcasting also can be applied between arrays of different sizes and shapes, enabling some concise and powerful manipulations. 
- We’ll show more examples of broadcasting later in the chapter when we introduce NumPy’s universal functions.

**Arithmetic Operation between Arrays**
- You may perform arithmetic operations and augmented assignments between arrays of the same shape. 
- Let’s multiply the one-dimensional arrays numbers and numbers2 (created below) that each contain five elements:
```python3
In [9]: numbers2 = np.linspace(1.1, 5.5, 5)
In [10]: numbers2
Out[10]: array([ 1.1, 2.2, 3.3, 4.4, 5.5])
In [11]: numbers * numbers2
Out[11]: array([ 12.1, 26.4, 42.9, 61.6, 82.5])
```
- The result is a new array formed by multiplying the arrays element-wise in each operand—11 * 1.1, 12 * 2.2, 13 * 3.3, etc. 
- Arithmetic between arrays of integers and floating-point numbers results in an array of floating-point numbers.
**Comparing arrays**
- You can compare arrays with individual values and with other arrays. Comparisons are performed element-wise. 
- Such comparisons produce arrays of Boolean values in which each element’s True or False value indicates the comparison result:
```python3
In [12]: numbers
Out[12]: array([11, 12, 13, 14, 15])
In [13]: numbers >= 13
Out[13]: array([False, False, True, True, True])
In [14]: numbers2
Out[14]: array([ 1.1, 2.2, 3.3, 4.4, 5.5])
In [15]: numbers2 < numbers
Out[15]: array([ True, True, True, True, True])
In [16]: numbers == numbers2
Out[16]: array([False, False, False, False,
False])
In [17]: numbers == numbers
Out[17]: array([ True, True, True, True, True])
```
## Reshaping and Transforming
**reshape vs. resize**
- The array methods reshape and resize both enable you to change an array’s dimensions. 
- Method reshape returns a view (shallow copy) of the original array with the new dimensions. It does not modify the original array:
```python3
In [1]: import numpy as np
In [2]: grades = np.array([[87, 96, 70], [100,
87, 90]])
In [3]: grades
Out[3]:
array([[ 87, 96, 70],
 [100, 87, 90]])
In [4]: grades.reshape(1, 6)
Out[4]: array([[ 87, 96, 70, 100, 87, 90]])
In [5]: grades
Out[5]:
array([[ 87, 96, 70],
 [100, 87, 90]])
```
- Method resize modifies the original array’s shape:
```python3
In [6]: grades.resize(1, 6)
In [7]: grades
Out[7]: array([[ 87, 96, 70, 100, 87, 90]])
```
**flatten vs. ravel**
- You can take a multidimensional array and flatten it into a
single dimension with the methods flatten and ravel.
Method flatten deep copies the original array’s data:
```python3
In [8]: grades = np.array([[87, 96, 70], [100,
87, 90]])
In [9]: grades
Out[9]:
array([[ 87, 96, 70],
 [100, 87, 90]])
In [10]: flattened = grades.flatten()
In [11]: flattened
Out[11]: array([ 87, 96, 70, 100, 87, 90])
In [12]: grades
Out[12]:
array([[ 87, 96, 70],
 [100, 87, 90]])
```
- To confirm that grades and flattened do not share the
data, let’s modify an element of flattened, then display
both arrays:
```python3
In [13]: flattened[0] = 100
In [14]: flattened
Out[14]: array([100, 96, 70, 100, 87, 90])
In [15]: grades
Out[15]:
array([[ 87, 96, 70],
 [100, 87, 90]])
```
- Method ravel produces a view of the original array, which
shares the grades array’s data:
```python3
In [16]: raveled = grades.ravel()
In [17]: raveled
Out[17]: array([ 87, 96, 70, 100, 87, 90])
In [18]: grades
Out[18]:
array([[ 87, 96, 70],
 [100, 87, 90]])
```
- To confirm that grades and raveled share the same data,
let’s modify an element of raveled, then display both
arrays:
```python3
In [19]: raveled[0] = 100
In [20]: raveled
Out[20]: array([100, 96, 70, 100, 87, 90])
In [21]: grades
Out[21]:
array([[100, 96, 70],
 [100, 87, 90]])
```
**Transposing Rows and Columns**
- You can quickly transpose an array’s rows and columns that is “flip” the array, so the rows become the columns and the columns become the rows. 
- The T attribute returns a transposed view (shallow copy) of the array. 
- The original grades array represents two students’ grades (the rows) on three exams (the columns). 
- Let’s transpose the rows and columns to view the data as the grades on three exams (the rows) for two students (the columns):
```python3
In [22]: grades.T
Out[22]:
array([[100, 100],
 [ 96, 87],
 [ 70, 90]])
 ```
- Transposing does not modify the original array:
```python3
In [23]: grades
Out[23]:
array([[100, 96, 70],
 [100, 87, 90]])
 ```
**Horizontal and Vertical Stacking**
- You can combine arrays by adding more columns or more rows—known as horizontal stacking and vertical stacking.
- Let’s create another 2-by-3 array of grades:
```python3
In [24]: grades2 = np.array([[94, 77, 90], [100,
81, 82]])
```
- Let’s assume grades2 represents three additional exam grades for the two students in the grades array. 
- We can combine grades and grades2 with NumPy’s hstack (horizontal stack) function by passing a tuple containing the arrays to combine. 
- The extra parentheses are required because hstack expects one argument:
```python3
In [25]: np.hstack((grades, grades2))
Out[25]:
array([[100, 96, 70, 94, 77, 90],
 [100, 87, 90, 100, 81, 82]])
```
- Next, let’s assume that grades2 represents two more students’ grades on three exams. 
- In this case, we can combine grades and grades2 with NumPy’s vstack (vertical stack) function:
```python3
In [26]: np.vstack((grades, grades2))
Out[26]:
array([[100, 96, 70],
 [100, 87, 90],
 [ 94, 77, 90],
 [100, 81, 82]])
 ```
 ## NumPy Calculation Methods
- An array has various methods that perform calculations using its contents. 
- By default, these methods ignore the array’s shape and use all the elements in the calculations.
- For example, calculating the mean of an array totals all of its elements regardless of its shape, then divides by the total number of elements. 
- You can perform these calculations on each dimension as well. 
- For example, in a two-dimensional array, you can calculate each row’s mean and each column’s mean.
- Consider an array representing four students’ grades on three exams:
```python3
In [1]: import numpy as np
In [2]: grades = np.array([[87, 96, 70], [100,
87, 90],
 ...: [94, 77, 90], [100, 81, 82]])
 ...:
In [3]: grades
Out[3]:
array([[ 87, 96, 70],
 [100, 87, 90],
 [ 94, 77, 90],
 [100, 81, 82]])
 ```
- We can use methods to calculate sum, min, max, mean, std (standard deviation) and var (variance)—each is a functionalstyle programming reduction:
```python3
In [4]: grades.sum()
Out[4]: 1054
In [5]: grades.min()
Out[5]: 70
In [6]: grades.max()
Out[6]: 100
In [7]: grades.mean()
Out[7]: 87.83333333333333
In [8]: grades.std()
Out[8]: 8.792357792739987
In [9]: grades.var()
Out[9]: 77.30555555555556
```
**Calculations by Row or Column**
- Many calculation methods can be performed on specific
array dimensions, known as the array’s axes. 
- These
methods receive an axis keyword argument that specifies
which dimension to use in the calculation, giving you a quick
way to perform calculations by row or column in a twodimensional array.
- Assume that you want to calculate the average grade on each
exam, represented by the columns of grades. 
- Specifying
axis=0 performs the calculation on all the row values within
each column:
```python3
In [10]: grades.mean(axis=0)
Out[10]: array([95.25, 85.25, 83. ])
```
- So 95.25 above is the average of the first column’s grades (87, 100, 94 and 100), 85.25 is the average of the second column’s grades (96, 87, 77 and 81) and 83 is the average of the third column’s grades (70, 90, 90 and 82). 
- Again, NumPy does not display trailing 0s to the right of the decimal point in '83.'. 
- Also note that it does display all element values in the same field width, which is why '83.' is followed by two spaces.
- Similarly, specifying axis=1 performs the calculation on all the column values within each individual row. 
- To calculate each student’s average grade for all exams, we can use:
```python3
In [11]: grades.mean(axis=1)
Out[11]: array([84.33333333, 92.33333333, 87., 87.66666667])
```
- This produces four averages—one each for the values in each row. 
- So 84.33333333 is the average of row 0’s grades (87, 96 and 70), and the other averages are for the remaining rows.
 ## Universal Functions
 - NumPy offers dozens of standalone universal functions (or ufuncs) that perform various element-wise operations. 
 - Each performs its task using one or two array or array-like (such as lists) arguments. 
 - Some of these functions are called when you use operators like + and * on arrays. 
 - Each returns a new array containing the results. 
 - Let’s create an array and calculate the square root of its values, using the sqrt universal function:
 ```python3
In [1]: import numpy as np
In [2]: numbers = np.array([1, 4, 9, 16, 25, 36])
In [3]: np.sqrt(numbers)
Out[3]: array([1., 2., 3., 4., 5., 6.])
 ```
 - Let’s add two arrays with the same shape, using the add universal function:
 ```python3
In [4]: numbers2 = np.arange(1, 7) * 10
In [5]: numbers2
Out[5]: array([10, 20, 30, 40, 50, 60])
In [6]: np.add(numbers, numbers2)
Out[6]: array([11, 24, 39, 56, 75, 96])
```
The expression np.add(numbers, numbers2) is equivalent to:
```numbers + numbers2```
**Broadcasting with Universal Functions**
- Let’s use the multiply universal function to multiply every element of numbers2 by the scalar value 5:
```python3
In [7]: np.multiply(numbers2, 5)
Out[7]: array([ 50, 100, 150, 200, 250, 300])
```
- The expression np.multiply(numbers2, 5) is equivalent to: numbers2 * 5
- Let’s reshape numbers2 into a 2-by-3 array, then multiply its values by a one-dimensional array of three elements:
```python3
In [8]: numbers3 = numbers2.reshape(2, 3)
In [9]: numbers3
Out[9]:
array([[10, 20, 30],
 [40, 50, 60]])
In [10]: numbers4 = np.array([2, 4, 6])
In [11]: np.multiply(numbers3, numbers4)
Out[11]:
array([[ 20, 80, 180],
 [ 80, 200, 360]])
```
- This works because numbers4 has the same length as each row of numbers3, so NumPy can apply the multiply operation by treating numbers4 as if it were the following array:
```python3
array([[2, 4, 6],
[2, 4, 6]])
```
- If a universal function receives two arrays of different shapes that do not support broadcasting, a ValueError occurs
## Views: Shallow Copies
- The previous chapter introduced view objects—that is, objects that “see” the data in other objects, rather than having their own copies of the data. 
- Views are also known as shallow copies. 
- Various array methods and slicing operations produce views of an array’s data.
- The array method view returns a new array object with a view of the original array object’s data. 
- First, let’s create an array and a view of that array:
```python3
In [1]: import numpy as np
In [2]: numbers = np.arange(1, 6)
In [3]: numbers
Out[3]: array([1, 2, 3, 4, 5])
In [4]: numbers2 = numbers.view()
In [5]: numbers2
Out[5]: array([1, 2, 3, 4, 5])
```
We can use the built-in id function to see that numbers and
numbers2 are different objects:
```python3
In [6]: id(numbers)
Out[6]: 4462958592
In [7]: id(numbers2)
Out[7]: 4590846240
```
- To prove that numbers2 views the same data as numbers, let’s modify an element in numbers, then display both arrays:
```
In [8]: numbers[1] *= 10
In [9]: numbers2
Out[9]: array([ 1, 20, 3, 4, 5])
In [10]: numbers
Out[10]: array([ 1, 20, 3, 4, 5])
```
Similarly, changing a value in the view also changes that value
in the original array:
```
In [11]: numbers2[1] /= 10
In [12]: numbers
Out[12]: array([1, 2, 3, 4, 5])
In [13]: numbers2
Out[13]: array([1, 2, 3, 4, 5])
```
**Slice Views**
- Slices also create views. 
- Let’s make numbers2 a slice that views only the first three elements of numbers:
```
In [14]: numbers2 = numbers[0:3]
In [15]: numbers2
Out[15]: array([1, 2, 3])
```
Again, we can confirm that numbers and numbers2 are different objects with id:
```python3
In [16]: id(numbers)
Out[16]: 4462958592
In [17]: id(numbers2)
Out[17]: 4590848000
```
We can confirm that numbers2 is a view of only the first three numbers elements by attempting to access numbers2[3], which produces an IndexError:
```python3
In [18]: numbers2[3]
IndexError Traceback
(most recent call last)
IndexError: index 3 is out of bounds for axis 0
with size 3
```
- Now, let’s modify an element both arrays share, then display them. 
- Again, we see that numbers2 is a view of numbers:
```python3
In [19]: numbers[1] *= 20
In [20]: numbers
Out[20]: array([1, 2, 3, 4, 5])
In [21]: numbers2
Out[21]: array([ 1, 40, 3])
```
 ## Deep Copies
- Though views are separate array objects, they save memory by sharing element data from other arrays. 
- However, when sharing mutable values, sometimes it’s necessary to create a deep copy with independent copies of the original data. 
- This is especially important in multi-core programming, where separate parts of your program could attempt to modify your data at the same time, possibly corrupting it.
- The array method copy returns a new array object with a deep copy of the original array object’s data. 
- First, let’s create an array and a deep copy of that array:
```python3
In [1]: import numpy as np
In [2]: numbers = np.arange(1, 6)
In [3]: numbers
Out[3]: array([1, 2, 3, 4, 5])
In [4]: numbers2 = numbers.copy()
In [5]: numbers2
Out[5]: array([1, 2, 3, 4, 5])
```
- To prove that numbers2 has a separate copy of the data in numbers, let’s modify an element in numbers, then display
both arrays:
```python3
In [6]: numbers[1] *= 10
In [7]: numbers
Out[7]: array([ 1, 20, 3, 4, 5])
In [8]: numbers2
Out[8]: array([ 1, 2, 3, 4, 5])
```
- As you can see, the change appears only in numbers.
**Shallow vs.Deep Copies for Other Types of Python Objects**
- In previous chapters, we covered shallow copying. 
- In this chapter, we’ve covered how to deep copy array objects using their copy method. 
- If you need deep copies of other types of Python objects, pass them to the copy module’s deepcopy function.
